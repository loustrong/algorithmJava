package com.tom.se.crazyit.chapter4;

/**
 * @descriptions: ArrayTest
 * @author: Tom
 * @date: 2021/1/12 下午 06:15
 * @version: 1.0
 */
public class ArrayTest {
    public static void main(String[] args) {
        // 一旦一個數組的初始化完成,數組在內存中所佔的空間
        // 將被固定下來,因此數組的長度將不可被改變;即使把
        // 某個數組元素的數據清空,但它所佔的空間依然被保留
        // 依然屬於該數組,數組的長度不變
        // 數組本身也是一種引用類型,定義一個變量時,僅僅表示引用定義了一個
        // 引用變量(也就是定義了一個指針),這個引用變量還未指向任何有效的內存
        // 因此在定義數組時不能指定數組的長度,只有對數組初始化才可以使用
        // 實際的數組對象被存儲在堆(heap)內存中;如果引用該數組對象的數組
        // 引用變量是一個局部變量,那麼它存儲在棧(stack)中.
        // 為什麼會有堆內存和棧內存的區分?
        // 當一個方法執行的時候,每個方法都會建立自己的內存棧,
        // 在這個方法內定義的變量將會逐個放入到這塊內存中,隨著方法的執行
        // 結束,這個方法的內存棧也將自然銷毀.因此,在所有方法中定義的局部變量
        // 都是放在棧內存中的;在程序中創建一個對象時,這個對象將被保存到運行時
        // 數據區,以便反復調用(因為對象的創建成本通常較大),
        // 這個運行時數據區就是堆內存.堆內存中的對象不會隨著方法的結束而銷毀
        // 即使方法結束后,這個對象還可能被另外一個引用變量所引用(在方法的參數
        // 傳遞時很常見),則這個對象依然不會被銷毀,只有當一個對象沒有任何引用變量
        // 引用它時,系統的垃圾回收器才會在合適的時候回收它.
        // 如果堆內存中數組不再有任何引用變量指向自己,則這個數組將稱為垃圾
        // 該數組所佔用的內存將會被系統的垃圾回收機制回收.因此為了讓垃圾回收機制
        // 回收一個數組所佔用的內存空間,可以將該數組變量設置為null,也就切斷了
        // 數組引用變量和實際數組之間的引用關係,實際數組也就成了垃圾.
        int[] intArray;
        intArray = new int[]{5, 6, 8, 20};
        // 定義一個Object數組類型的變量,變量名為objArr;
        Object[] objArr;
        objArr = new String[]{"Java", "李剛"};
        Object[] objArray2;
        objArray2 = new Object[]{"Java", "李剛"};
        for (Object book: objArr
             ) {
            System.out.println((String) book);
        }
    }
}
